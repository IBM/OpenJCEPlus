/*
 * Copyright IBM Corp. 2025
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms provided by IBM in the LICENSE file that accompanied
 * this code, including the "Classpath" Exception described therein.
 */

package ibm.jceplus.junit.base;

import java.io.ByteArrayOutputStream;
import java.security.AlgorithmParameters;
import java.util.Locale;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;

public class BaseTestPBECipherInterop extends BaseTestJunit5Interop {

    private byte[] ivBytes = {
        0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
        0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
    };
    private int iterationCount = 300000;
    private byte[] salt = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};

    @ParameterizedTest
    @CsvSource({"PBEWithHmacSHA1AndAES_128", "PBEWithHmacSHA1AndAES_256", "PBEWithHmacSHA224AndAES_128", "PBEWithHmacSHA224AndAES_256",
        "PBEWithHmacSHA256AndAES_128", "PBEWithHmacSHA256AndAES_256", "PBEWithHmacSHA384AndAES_128", "PBEWithHmacSHA384AndAES_256",
        "PBEWithHmacSHA512AndAES_128", "PBEWithHmacSHA512AndAES_256", "PBEWithHmacSHA512/224AndAES_128", "PBEWithHmacSHA512/224AndAES_256",
        "PBEWithHmacSHA512/256AndAES_128", "PBEWithHmacSHA512/256AndAES_256", "PBEWithHmacSha1AndAES_128/CBC/PKCS5PAdding",
        "PBEWithHmacSha1AndAES_256/CBC/PKCS5PAdding", "PBEWithHmacSHA224andAES_128/CBC/PkCS5Padding", "PBEWithHmacSHA224andAES_256/CBC/PkCS5Padding",
        "PBEWithHmacSHA256AndAes_128/CBC/PKCS5PaddIng", "PBEWithHmacSHA256AndAes_256/CBC/PKCS5PaddIng", "PBEWithHmacSHa384AndAES_128/CbC/PKCS5Padding",
        "PBEWithHmacSHa384AndAES_256/CbC/PKCS5Padding", "PBEWithHmacSHA512andAES_128/CBc/PKCS5Padding", "PBEWithHmacSHA512andAES_256/CBc/PKCS5Padding",
        "PBEWithHmacSha512/224andAES_128/cBC/PKCS5Padding", "PBEWithHmacSha512/224andAES_256/cBC/PKCS5Padding", "PBEWithHmacShA512/256AndAES_128/CBC/pkCS5Padding",
        "PBEWithHmacShA512/256AndAES_256/CBC/pkCS5Padding"})
    public void testPBE(String algorithm) throws Exception {
        test(algorithm, true, 1);  // salt, ic, IV supplied by the application
        test(algorithm, true, 2); // salt, ic, IV generated by the implementation
        test(algorithm, false, 1);  // salt, ic, IV supplied by the application
        test(algorithm, false, 2); // salt, ic, IV generated by the implementation
    }

    private void test(String algo, boolean suppliedParams, int variation)
        throws Exception {
        
        String provider, interopProvider;
        if (variation == 1) {
            provider = getProviderName();
            interopProvider = getInteropProviderName();
        } else {
            provider = getInteropProviderName();
            interopProvider = getProviderName();
        }

        // Create PBE key
        SecretKey pbeKey = createKey(algo, provider);

        // Create PBE cipher
        Cipher cipherEncrypt = createCipher(Cipher.ENCRYPT_MODE, algo, pbeKey, suppliedParams, provider);
        Cipher cipherWrap = createCipher(Cipher.WRAP_MODE, algo, pbeKey, suppliedParams, provider);
        Cipher cipherEncryptUpdate = createCipher(Cipher.ENCRYPT_MODE, algo, pbeKey, suppliedParams, provider);

        byte[] cleartext = "This is just an example".getBytes();

        // Encrypt
        byte[] ciphertext = cipherEncrypt.doFinal(cleartext);

        // Wrap
        byte[] wrappedKey = cipherWrap.wrap(pbeKey);

        // Update
        byte[] cipherUpdateText = update(cipherEncryptUpdate, cleartext, 4);

        // Decrypt
        Cipher cipherDecrypt = createCipher(Cipher.DECRYPT_MODE, algo, pbeKey, cipherEncrypt.getParameters(), interopProvider);
        byte[] cleartext2 = cipherDecrypt.doFinal(ciphertext);

        // Unwrap
        Cipher cipherUnwrap = createCipher(Cipher.UNWRAP_MODE, algo, pbeKey, cipherWrap.getParameters(), interopProvider);
        SecretKey unwrappedKey = (SecretKey) cipherUnwrap.unwrap(wrappedKey, pbeKey.getAlgorithm(), Cipher.SECRET_KEY);

        // Decrypt Update
        Cipher cipherDecryptUpdate = createCipher(Cipher.DECRYPT_MODE, algo, pbeKey, cipherEncryptUpdate.getParameters(), interopProvider);
        byte[] cleartextUpdate = update(cipherDecryptUpdate, cipherUpdateText, 5);

        assertArrayEquals(cleartext, cleartext2);
        assertArrayEquals(pbeKey.getEncoded(), unwrappedKey.getEncoded());
        assertArrayEquals(cleartext, cleartextUpdate);
    }

    private SecretKey createKey(String algorithm, String provider) throws Exception {
        PBEKeySpec pbeKeySpec = new PBEKeySpec("mypassword".toCharArray());
        int modeIdx = algorithm.toUpperCase(Locale.ENGLISH).indexOf("/CBC");
        String keyAlgo = (modeIdx == -1 ? algorithm : algorithm.substring(0, modeIdx));
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(keyAlgo, provider);
        SecretKey pbeKey = keyFactory.generateSecret(pbeKeySpec);

        return pbeKey;
    }

    private Cipher createCipher(int mode, String algorithm, SecretKey pbeKey, boolean suppliedParams, String provider) throws Exception {
        Cipher c = Cipher.getInstance(algorithm, provider);
        if (suppliedParams) {
            c.init(mode, pbeKey,
                new PBEParameterSpec(salt, iterationCount,
                    new IvParameterSpec(ivBytes)));
        } else {
            c.init(mode, pbeKey);
        }

        return c;
    }

    private Cipher createCipher(int mode, String algorithm, SecretKey pbeKey, AlgorithmParameters params, String provider) throws Exception {
        Cipher c = Cipher.getInstance(algorithm, provider);
        c.init(mode, pbeKey, params);
        return c;
    }

    private byte[] update(Cipher c, byte[] text, int offset) throws Exception {
        byte[] update1 = c.update(text, 0, offset);
        byte[] update2 = c.update(text, offset, offset);
        byte[] update3 = c.update(text, 2 * offset, text.length - (2 * offset));
        byte[] finalUpdate = c.doFinal();
        ByteArrayOutputStream encryptStream = new ByteArrayOutputStream();
        encryptStream.write(update1);
        encryptStream.write(update2);
        encryptStream.write(update3);
        encryptStream.write(finalUpdate);
        finalUpdate = encryptStream.toByteArray();

        return finalUpdate;
    }
}

